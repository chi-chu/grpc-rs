// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `MediaTransfer.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct AddSessionRequest {
    // message fields
    pub session_id: ::std::string::String,
    pub local_sdp: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddSessionRequest {
    fn default() -> &'a AddSessionRequest {
        <AddSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddSessionRequest {
    pub fn new() -> AddSessionRequest {
        ::std::default::Default::default()
    }

    // string session_id = 1;


    pub fn get_session_id(&self) -> &str {
        &self.session_id
    }
    pub fn clear_session_id(&mut self) {
        self.session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        &mut self.session_id
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_id, ::std::string::String::new())
    }

    // string local_sdp = 2;


    pub fn get_local_sdp(&self) -> &str {
        &self.local_sdp
    }
    pub fn clear_local_sdp(&mut self) {
        self.local_sdp.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_sdp(&mut self, v: ::std::string::String) {
        self.local_sdp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_sdp(&mut self) -> &mut ::std::string::String {
        &mut self.local_sdp
    }

    // Take field
    pub fn take_local_sdp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_sdp, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddSessionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_sdp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.session_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_id);
        }
        if !self.local_sdp.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.local_sdp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.session_id.is_empty() {
            os.write_string(1, &self.session_id)?;
        }
        if !self.local_sdp.is_empty() {
            os.write_string(2, &self.local_sdp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddSessionRequest {
        AddSessionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_id",
                |m: &AddSessionRequest| { &m.session_id },
                |m: &mut AddSessionRequest| { &mut m.session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "local_sdp",
                |m: &AddSessionRequest| { &m.local_sdp },
                |m: &mut AddSessionRequest| { &mut m.local_sdp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddSessionRequest>(
                "AddSessionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddSessionRequest {
        static instance: ::protobuf::rt::LazyV2<AddSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddSessionRequest::new)
    }
}

impl ::protobuf::Clear for AddSessionRequest {
    fn clear(&mut self) {
        self.session_id.clear();
        self.local_sdp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddSessionResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub local_sdp: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddSessionResponse {
    fn default() -> &'a AddSessionResponse {
        <AddSessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddSessionResponse {
    pub fn new() -> AddSessionResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // string local_sdp = 2;


    pub fn get_local_sdp(&self) -> &str {
        &self.local_sdp
    }
    pub fn clear_local_sdp(&mut self) {
        self.local_sdp.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_sdp(&mut self, v: ::std::string::String) {
        self.local_sdp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_sdp(&mut self) -> &mut ::std::string::String {
        &mut self.local_sdp
    }

    // Take field
    pub fn take_local_sdp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_sdp, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddSessionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_sdp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.local_sdp.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.local_sdp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.local_sdp.is_empty() {
            os.write_string(2, &self.local_sdp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddSessionResponse {
        AddSessionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &AddSessionResponse| { &m.result },
                |m: &mut AddSessionResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "local_sdp",
                |m: &AddSessionResponse| { &m.local_sdp },
                |m: &mut AddSessionResponse| { &mut m.local_sdp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddSessionResponse>(
                "AddSessionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddSessionResponse {
        static instance: ::protobuf::rt::LazyV2<AddSessionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddSessionResponse::new)
    }
}

impl ::protobuf::Clear for AddSessionResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.local_sdp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddSessionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateSessionRequest {
    // message fields
    pub session_id: ::std::string::String,
    pub is_local: bool,
    pub sdp: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateSessionRequest {
    fn default() -> &'a UpdateSessionRequest {
        <UpdateSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSessionRequest {
    pub fn new() -> UpdateSessionRequest {
        ::std::default::Default::default()
    }

    // string session_id = 1;


    pub fn get_session_id(&self) -> &str {
        &self.session_id
    }
    pub fn clear_session_id(&mut self) {
        self.session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        &mut self.session_id
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_id, ::std::string::String::new())
    }

    // bool is_local = 2;


    pub fn get_is_local(&self) -> bool {
        self.is_local
    }
    pub fn clear_is_local(&mut self) {
        self.is_local = false;
    }

    // Param is passed by value, moved
    pub fn set_is_local(&mut self, v: bool) {
        self.is_local = v;
    }

    // string sdp = 3;


    pub fn get_sdp(&self) -> &str {
        &self.sdp
    }
    pub fn clear_sdp(&mut self) {
        self.sdp.clear();
    }

    // Param is passed by value, moved
    pub fn set_sdp(&mut self, v: ::std::string::String) {
        self.sdp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdp(&mut self) -> &mut ::std::string::String {
        &mut self.sdp
    }

    // Take field
    pub fn take_sdp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sdp, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateSessionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_local = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sdp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.session_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_id);
        }
        if self.is_local != false {
            my_size += 2;
        }
        if !self.sdp.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sdp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.session_id.is_empty() {
            os.write_string(1, &self.session_id)?;
        }
        if self.is_local != false {
            os.write_bool(2, self.is_local)?;
        }
        if !self.sdp.is_empty() {
            os.write_string(3, &self.sdp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSessionRequest {
        UpdateSessionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_id",
                |m: &UpdateSessionRequest| { &m.session_id },
                |m: &mut UpdateSessionRequest| { &mut m.session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_local",
                |m: &UpdateSessionRequest| { &m.is_local },
                |m: &mut UpdateSessionRequest| { &mut m.is_local },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sdp",
                |m: &UpdateSessionRequest| { &m.sdp },
                |m: &mut UpdateSessionRequest| { &mut m.sdp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateSessionRequest>(
                "UpdateSessionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateSessionRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateSessionRequest::new)
    }
}

impl ::protobuf::Clear for UpdateSessionRequest {
    fn clear(&mut self) {
        self.session_id.clear();
        self.is_local = false;
        self.sdp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateSessionResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub sdp: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateSessionResponse {
    fn default() -> &'a UpdateSessionResponse {
        <UpdateSessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSessionResponse {
    pub fn new() -> UpdateSessionResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // string sdp = 2;


    pub fn get_sdp(&self) -> &str {
        &self.sdp
    }
    pub fn clear_sdp(&mut self) {
        self.sdp.clear();
    }

    // Param is passed by value, moved
    pub fn set_sdp(&mut self, v: ::std::string::String) {
        self.sdp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdp(&mut self) -> &mut ::std::string::String {
        &mut self.sdp
    }

    // Take field
    pub fn take_sdp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sdp, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateSessionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sdp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.sdp.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sdp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.sdp.is_empty() {
            os.write_string(2, &self.sdp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSessionResponse {
        UpdateSessionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &UpdateSessionResponse| { &m.result },
                |m: &mut UpdateSessionResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sdp",
                |m: &UpdateSessionResponse| { &m.sdp },
                |m: &mut UpdateSessionResponse| { &mut m.sdp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateSessionResponse>(
                "UpdateSessionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateSessionResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateSessionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateSessionResponse::new)
    }
}

impl ::protobuf::Clear for UpdateSessionResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.sdp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSessionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSessionRequest {
    // message fields
    pub session_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSessionRequest {
    fn default() -> &'a DeleteSessionRequest {
        <DeleteSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSessionRequest {
    pub fn new() -> DeleteSessionRequest {
        ::std::default::Default::default()
    }

    // string session_id = 1;


    pub fn get_session_id(&self) -> &str {
        &self.session_id
    }
    pub fn clear_session_id(&mut self) {
        self.session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        &mut self.session_id
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteSessionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.session_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.session_id.is_empty() {
            os.write_string(1, &self.session_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSessionRequest {
        DeleteSessionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_id",
                |m: &DeleteSessionRequest| { &m.session_id },
                |m: &mut DeleteSessionRequest| { &mut m.session_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteSessionRequest>(
                "DeleteSessionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteSessionRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteSessionRequest::new)
    }
}

impl ::protobuf::Clear for DeleteSessionRequest {
    fn clear(&mut self) {
        self.session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSessionResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSessionResponse {
    fn default() -> &'a DeleteSessionResponse {
        <DeleteSessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSessionResponse {
    pub fn new() -> DeleteSessionResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }
}

impl ::protobuf::Message for DeleteSessionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSessionResponse {
        DeleteSessionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &DeleteSessionResponse| { &m.result },
                |m: &mut DeleteSessionResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteSessionResponse>(
                "DeleteSessionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteSessionResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteSessionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteSessionResponse::new)
    }
}

impl ::protobuf::Clear for DeleteSessionResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSessionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddTransferRuleRequest {
    // message fields
    pub rule_id: ::std::string::String,
    pub session_id_from: ::std::string::String,
    pub session_id_to: ::std::string::String,
    pub rtpids_from: ::protobuf::RepeatedField<::std::string::String>,
    pub rtpids_to: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddTransferRuleRequest {
    fn default() -> &'a AddTransferRuleRequest {
        <AddTransferRuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddTransferRuleRequest {
    pub fn new() -> AddTransferRuleRequest {
        ::std::default::Default::default()
    }

    // string rule_id = 1;


    pub fn get_rule_id(&self) -> &str {
        &self.rule_id
    }
    pub fn clear_rule_id(&mut self) {
        self.rule_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_rule_id(&mut self, v: ::std::string::String) {
        self.rule_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rule_id(&mut self) -> &mut ::std::string::String {
        &mut self.rule_id
    }

    // Take field
    pub fn take_rule_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rule_id, ::std::string::String::new())
    }

    // string session_id_from = 2;


    pub fn get_session_id_from(&self) -> &str {
        &self.session_id_from
    }
    pub fn clear_session_id_from(&mut self) {
        self.session_id_from.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_id_from(&mut self, v: ::std::string::String) {
        self.session_id_from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id_from(&mut self) -> &mut ::std::string::String {
        &mut self.session_id_from
    }

    // Take field
    pub fn take_session_id_from(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_id_from, ::std::string::String::new())
    }

    // string session_id_to = 3;


    pub fn get_session_id_to(&self) -> &str {
        &self.session_id_to
    }
    pub fn clear_session_id_to(&mut self) {
        self.session_id_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_id_to(&mut self, v: ::std::string::String) {
        self.session_id_to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id_to(&mut self) -> &mut ::std::string::String {
        &mut self.session_id_to
    }

    // Take field
    pub fn take_session_id_to(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_id_to, ::std::string::String::new())
    }

    // repeated string rtpids_from = 4;


    pub fn get_rtpids_from(&self) -> &[::std::string::String] {
        &self.rtpids_from
    }
    pub fn clear_rtpids_from(&mut self) {
        self.rtpids_from.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpids_from(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rtpids_from = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rtpids_from(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rtpids_from
    }

    // Take field
    pub fn take_rtpids_from(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rtpids_from, ::protobuf::RepeatedField::new())
    }

    // repeated string rtpids_to = 5;


    pub fn get_rtpids_to(&self) -> &[::std::string::String] {
        &self.rtpids_to
    }
    pub fn clear_rtpids_to(&mut self) {
        self.rtpids_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpids_to(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rtpids_to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rtpids_to(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rtpids_to
    }

    // Take field
    pub fn take_rtpids_to(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rtpids_to, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddTransferRuleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rule_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_id_from)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_id_to)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rtpids_from)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rtpids_to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.rule_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rule_id);
        }
        if !self.session_id_from.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.session_id_from);
        }
        if !self.session_id_to.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.session_id_to);
        }
        for value in &self.rtpids_from {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.rtpids_to {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.rule_id.is_empty() {
            os.write_string(1, &self.rule_id)?;
        }
        if !self.session_id_from.is_empty() {
            os.write_string(2, &self.session_id_from)?;
        }
        if !self.session_id_to.is_empty() {
            os.write_string(3, &self.session_id_to)?;
        }
        for v in &self.rtpids_from {
            os.write_string(4, &v)?;
        };
        for v in &self.rtpids_to {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddTransferRuleRequest {
        AddTransferRuleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rule_id",
                |m: &AddTransferRuleRequest| { &m.rule_id },
                |m: &mut AddTransferRuleRequest| { &mut m.rule_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_id_from",
                |m: &AddTransferRuleRequest| { &m.session_id_from },
                |m: &mut AddTransferRuleRequest| { &mut m.session_id_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_id_to",
                |m: &AddTransferRuleRequest| { &m.session_id_to },
                |m: &mut AddTransferRuleRequest| { &mut m.session_id_to },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpids_from",
                |m: &AddTransferRuleRequest| { &m.rtpids_from },
                |m: &mut AddTransferRuleRequest| { &mut m.rtpids_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpids_to",
                |m: &AddTransferRuleRequest| { &m.rtpids_to },
                |m: &mut AddTransferRuleRequest| { &mut m.rtpids_to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddTransferRuleRequest>(
                "AddTransferRuleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddTransferRuleRequest {
        static instance: ::protobuf::rt::LazyV2<AddTransferRuleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddTransferRuleRequest::new)
    }
}

impl ::protobuf::Clear for AddTransferRuleRequest {
    fn clear(&mut self) {
        self.rule_id.clear();
        self.session_id_from.clear();
        self.session_id_to.clear();
        self.rtpids_from.clear();
        self.rtpids_to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddTransferRuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddTransferRuleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddTransferRuleResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub rtpids_from: ::protobuf::RepeatedField<::std::string::String>,
    pub rtpids_to: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddTransferRuleResponse {
    fn default() -> &'a AddTransferRuleResponse {
        <AddTransferRuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddTransferRuleResponse {
    pub fn new() -> AddTransferRuleResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // repeated string rtpids_from = 2;


    pub fn get_rtpids_from(&self) -> &[::std::string::String] {
        &self.rtpids_from
    }
    pub fn clear_rtpids_from(&mut self) {
        self.rtpids_from.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpids_from(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rtpids_from = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rtpids_from(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rtpids_from
    }

    // Take field
    pub fn take_rtpids_from(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rtpids_from, ::protobuf::RepeatedField::new())
    }

    // repeated string rtpids_to = 3;


    pub fn get_rtpids_to(&self) -> &[::std::string::String] {
        &self.rtpids_to
    }
    pub fn clear_rtpids_to(&mut self) {
        self.rtpids_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpids_to(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rtpids_to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rtpids_to(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rtpids_to
    }

    // Take field
    pub fn take_rtpids_to(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rtpids_to, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddTransferRuleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rtpids_from)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rtpids_to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.rtpids_from {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.rtpids_to {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.rtpids_from {
            os.write_string(2, &v)?;
        };
        for v in &self.rtpids_to {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddTransferRuleResponse {
        AddTransferRuleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &AddTransferRuleResponse| { &m.result },
                |m: &mut AddTransferRuleResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpids_from",
                |m: &AddTransferRuleResponse| { &m.rtpids_from },
                |m: &mut AddTransferRuleResponse| { &mut m.rtpids_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpids_to",
                |m: &AddTransferRuleResponse| { &m.rtpids_to },
                |m: &mut AddTransferRuleResponse| { &mut m.rtpids_to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddTransferRuleResponse>(
                "AddTransferRuleResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddTransferRuleResponse {
        static instance: ::protobuf::rt::LazyV2<AddTransferRuleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddTransferRuleResponse::new)
    }
}

impl ::protobuf::Clear for AddTransferRuleResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.rtpids_from.clear();
        self.rtpids_to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddTransferRuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddTransferRuleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateTransferRuleRequest {
    // message fields
    pub rule_id: ::std::string::String,
    pub rtpids_from: ::protobuf::RepeatedField<::std::string::String>,
    pub rtpids_to: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateTransferRuleRequest {
    fn default() -> &'a UpdateTransferRuleRequest {
        <UpdateTransferRuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTransferRuleRequest {
    pub fn new() -> UpdateTransferRuleRequest {
        ::std::default::Default::default()
    }

    // string rule_id = 1;


    pub fn get_rule_id(&self) -> &str {
        &self.rule_id
    }
    pub fn clear_rule_id(&mut self) {
        self.rule_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_rule_id(&mut self, v: ::std::string::String) {
        self.rule_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rule_id(&mut self) -> &mut ::std::string::String {
        &mut self.rule_id
    }

    // Take field
    pub fn take_rule_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rule_id, ::std::string::String::new())
    }

    // repeated string rtpids_from = 2;


    pub fn get_rtpids_from(&self) -> &[::std::string::String] {
        &self.rtpids_from
    }
    pub fn clear_rtpids_from(&mut self) {
        self.rtpids_from.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpids_from(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rtpids_from = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rtpids_from(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rtpids_from
    }

    // Take field
    pub fn take_rtpids_from(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rtpids_from, ::protobuf::RepeatedField::new())
    }

    // repeated string rtpids_to = 3;


    pub fn get_rtpids_to(&self) -> &[::std::string::String] {
        &self.rtpids_to
    }
    pub fn clear_rtpids_to(&mut self) {
        self.rtpids_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpids_to(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rtpids_to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rtpids_to(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rtpids_to
    }

    // Take field
    pub fn take_rtpids_to(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rtpids_to, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UpdateTransferRuleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rule_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rtpids_from)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rtpids_to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.rule_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rule_id);
        }
        for value in &self.rtpids_from {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.rtpids_to {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.rule_id.is_empty() {
            os.write_string(1, &self.rule_id)?;
        }
        for v in &self.rtpids_from {
            os.write_string(2, &v)?;
        };
        for v in &self.rtpids_to {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateTransferRuleRequest {
        UpdateTransferRuleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rule_id",
                |m: &UpdateTransferRuleRequest| { &m.rule_id },
                |m: &mut UpdateTransferRuleRequest| { &mut m.rule_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpids_from",
                |m: &UpdateTransferRuleRequest| { &m.rtpids_from },
                |m: &mut UpdateTransferRuleRequest| { &mut m.rtpids_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpids_to",
                |m: &UpdateTransferRuleRequest| { &m.rtpids_to },
                |m: &mut UpdateTransferRuleRequest| { &mut m.rtpids_to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateTransferRuleRequest>(
                "UpdateTransferRuleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateTransferRuleRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateTransferRuleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateTransferRuleRequest::new)
    }
}

impl ::protobuf::Clear for UpdateTransferRuleRequest {
    fn clear(&mut self) {
        self.rule_id.clear();
        self.rtpids_from.clear();
        self.rtpids_to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateTransferRuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTransferRuleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateTransferRuleResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub rtpids_from: ::protobuf::RepeatedField<::std::string::String>,
    pub rtpids_to: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateTransferRuleResponse {
    fn default() -> &'a UpdateTransferRuleResponse {
        <UpdateTransferRuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTransferRuleResponse {
    pub fn new() -> UpdateTransferRuleResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // repeated string rtpids_from = 2;


    pub fn get_rtpids_from(&self) -> &[::std::string::String] {
        &self.rtpids_from
    }
    pub fn clear_rtpids_from(&mut self) {
        self.rtpids_from.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpids_from(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rtpids_from = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rtpids_from(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rtpids_from
    }

    // Take field
    pub fn take_rtpids_from(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rtpids_from, ::protobuf::RepeatedField::new())
    }

    // repeated string rtpids_to = 3;


    pub fn get_rtpids_to(&self) -> &[::std::string::String] {
        &self.rtpids_to
    }
    pub fn clear_rtpids_to(&mut self) {
        self.rtpids_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpids_to(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rtpids_to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rtpids_to(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rtpids_to
    }

    // Take field
    pub fn take_rtpids_to(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rtpids_to, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UpdateTransferRuleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rtpids_from)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rtpids_to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.rtpids_from {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.rtpids_to {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.rtpids_from {
            os.write_string(2, &v)?;
        };
        for v in &self.rtpids_to {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateTransferRuleResponse {
        UpdateTransferRuleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &UpdateTransferRuleResponse| { &m.result },
                |m: &mut UpdateTransferRuleResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpids_from",
                |m: &UpdateTransferRuleResponse| { &m.rtpids_from },
                |m: &mut UpdateTransferRuleResponse| { &mut m.rtpids_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpids_to",
                |m: &UpdateTransferRuleResponse| { &m.rtpids_to },
                |m: &mut UpdateTransferRuleResponse| { &mut m.rtpids_to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateTransferRuleResponse>(
                "UpdateTransferRuleResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateTransferRuleResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateTransferRuleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateTransferRuleResponse::new)
    }
}

impl ::protobuf::Clear for UpdateTransferRuleResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.rtpids_from.clear();
        self.rtpids_to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateTransferRuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTransferRuleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteTransferRuleRequest {
    // message fields
    pub rule_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteTransferRuleRequest {
    fn default() -> &'a DeleteTransferRuleRequest {
        <DeleteTransferRuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTransferRuleRequest {
    pub fn new() -> DeleteTransferRuleRequest {
        ::std::default::Default::default()
    }

    // string rule_id = 1;


    pub fn get_rule_id(&self) -> &str {
        &self.rule_id
    }
    pub fn clear_rule_id(&mut self) {
        self.rule_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_rule_id(&mut self, v: ::std::string::String) {
        self.rule_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rule_id(&mut self) -> &mut ::std::string::String {
        &mut self.rule_id
    }

    // Take field
    pub fn take_rule_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rule_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteTransferRuleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rule_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.rule_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rule_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.rule_id.is_empty() {
            os.write_string(1, &self.rule_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteTransferRuleRequest {
        DeleteTransferRuleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rule_id",
                |m: &DeleteTransferRuleRequest| { &m.rule_id },
                |m: &mut DeleteTransferRuleRequest| { &mut m.rule_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteTransferRuleRequest>(
                "DeleteTransferRuleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteTransferRuleRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteTransferRuleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteTransferRuleRequest::new)
    }
}

impl ::protobuf::Clear for DeleteTransferRuleRequest {
    fn clear(&mut self) {
        self.rule_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteTransferRuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTransferRuleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteTransferRuleResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteTransferRuleResponse {
    fn default() -> &'a DeleteTransferRuleResponse {
        <DeleteTransferRuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTransferRuleResponse {
    pub fn new() -> DeleteTransferRuleResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }
}

impl ::protobuf::Message for DeleteTransferRuleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteTransferRuleResponse {
        DeleteTransferRuleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &DeleteTransferRuleResponse| { &m.result },
                |m: &mut DeleteTransferRuleResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteTransferRuleResponse>(
                "DeleteTransferRuleResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteTransferRuleResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteTransferRuleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteTransferRuleResponse::new)
    }
}

impl ::protobuf::Clear for DeleteTransferRuleResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteTransferRuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTransferRuleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuerySessionRequest {
    // message fields
    pub session_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySessionRequest {
    fn default() -> &'a QuerySessionRequest {
        <QuerySessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySessionRequest {
    pub fn new() -> QuerySessionRequest {
        ::std::default::Default::default()
    }

    // string session_id = 1;


    pub fn get_session_id(&self) -> &str {
        &self.session_id
    }
    pub fn clear_session_id(&mut self) {
        self.session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        &mut self.session_id
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySessionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.session_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.session_id.is_empty() {
            os.write_string(1, &self.session_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySessionRequest {
        QuerySessionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_id",
                |m: &QuerySessionRequest| { &m.session_id },
                |m: &mut QuerySessionRequest| { &mut m.session_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuerySessionRequest>(
                "QuerySessionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySessionRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySessionRequest::new)
    }
}

impl ::protobuf::Clear for QuerySessionRequest {
    fn clear(&mut self) {
        self.session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuerySessionResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub local_sdp: ::std::string::String,
    pub remote_sdp: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySessionResponse {
    fn default() -> &'a QuerySessionResponse {
        <QuerySessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySessionResponse {
    pub fn new() -> QuerySessionResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // string local_sdp = 2;


    pub fn get_local_sdp(&self) -> &str {
        &self.local_sdp
    }
    pub fn clear_local_sdp(&mut self) {
        self.local_sdp.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_sdp(&mut self, v: ::std::string::String) {
        self.local_sdp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_sdp(&mut self) -> &mut ::std::string::String {
        &mut self.local_sdp
    }

    // Take field
    pub fn take_local_sdp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_sdp, ::std::string::String::new())
    }

    // string remote_sdp = 3;


    pub fn get_remote_sdp(&self) -> &str {
        &self.remote_sdp
    }
    pub fn clear_remote_sdp(&mut self) {
        self.remote_sdp.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_sdp(&mut self, v: ::std::string::String) {
        self.remote_sdp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_sdp(&mut self) -> &mut ::std::string::String {
        &mut self.remote_sdp
    }

    // Take field
    pub fn take_remote_sdp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_sdp, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySessionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_sdp)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_sdp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.local_sdp.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.local_sdp);
        }
        if !self.remote_sdp.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.remote_sdp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.local_sdp.is_empty() {
            os.write_string(2, &self.local_sdp)?;
        }
        if !self.remote_sdp.is_empty() {
            os.write_string(3, &self.remote_sdp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySessionResponse {
        QuerySessionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &QuerySessionResponse| { &m.result },
                |m: &mut QuerySessionResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "local_sdp",
                |m: &QuerySessionResponse| { &m.local_sdp },
                |m: &mut QuerySessionResponse| { &mut m.local_sdp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remote_sdp",
                |m: &QuerySessionResponse| { &m.remote_sdp },
                |m: &mut QuerySessionResponse| { &mut m.remote_sdp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuerySessionResponse>(
                "QuerySessionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySessionResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySessionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySessionResponse::new)
    }
}

impl ::protobuf::Clear for QuerySessionResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.local_sdp.clear();
        self.remote_sdp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySessionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryTransferRuleRequest {
    // message fields
    pub rule_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTransferRuleRequest {
    fn default() -> &'a QueryTransferRuleRequest {
        <QueryTransferRuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryTransferRuleRequest {
    pub fn new() -> QueryTransferRuleRequest {
        ::std::default::Default::default()
    }

    // string rule_id = 1;


    pub fn get_rule_id(&self) -> &str {
        &self.rule_id
    }
    pub fn clear_rule_id(&mut self) {
        self.rule_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_rule_id(&mut self, v: ::std::string::String) {
        self.rule_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rule_id(&mut self) -> &mut ::std::string::String {
        &mut self.rule_id
    }

    // Take field
    pub fn take_rule_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rule_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryTransferRuleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rule_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.rule_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rule_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.rule_id.is_empty() {
            os.write_string(1, &self.rule_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTransferRuleRequest {
        QueryTransferRuleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rule_id",
                |m: &QueryTransferRuleRequest| { &m.rule_id },
                |m: &mut QueryTransferRuleRequest| { &mut m.rule_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryTransferRuleRequest>(
                "QueryTransferRuleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryTransferRuleRequest {
        static instance: ::protobuf::rt::LazyV2<QueryTransferRuleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTransferRuleRequest::new)
    }
}

impl ::protobuf::Clear for QueryTransferRuleRequest {
    fn clear(&mut self) {
        self.rule_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryTransferRuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTransferRuleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryTransferRuleResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub session_id_from: ::std::string::String,
    pub session_id_to: ::std::string::String,
    pub rtpids_from: ::protobuf::RepeatedField<::std::string::String>,
    pub rtpids_to: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTransferRuleResponse {
    fn default() -> &'a QueryTransferRuleResponse {
        <QueryTransferRuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryTransferRuleResponse {
    pub fn new() -> QueryTransferRuleResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // string session_id_from = 2;


    pub fn get_session_id_from(&self) -> &str {
        &self.session_id_from
    }
    pub fn clear_session_id_from(&mut self) {
        self.session_id_from.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_id_from(&mut self, v: ::std::string::String) {
        self.session_id_from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id_from(&mut self) -> &mut ::std::string::String {
        &mut self.session_id_from
    }

    // Take field
    pub fn take_session_id_from(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_id_from, ::std::string::String::new())
    }

    // string session_id_to = 3;


    pub fn get_session_id_to(&self) -> &str {
        &self.session_id_to
    }
    pub fn clear_session_id_to(&mut self) {
        self.session_id_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_id_to(&mut self, v: ::std::string::String) {
        self.session_id_to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id_to(&mut self) -> &mut ::std::string::String {
        &mut self.session_id_to
    }

    // Take field
    pub fn take_session_id_to(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_id_to, ::std::string::String::new())
    }

    // repeated string rtpids_from = 4;


    pub fn get_rtpids_from(&self) -> &[::std::string::String] {
        &self.rtpids_from
    }
    pub fn clear_rtpids_from(&mut self) {
        self.rtpids_from.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpids_from(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rtpids_from = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rtpids_from(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rtpids_from
    }

    // Take field
    pub fn take_rtpids_from(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rtpids_from, ::protobuf::RepeatedField::new())
    }

    // repeated string rtpids_to = 5;


    pub fn get_rtpids_to(&self) -> &[::std::string::String] {
        &self.rtpids_to
    }
    pub fn clear_rtpids_to(&mut self) {
        self.rtpids_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpids_to(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rtpids_to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rtpids_to(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rtpids_to
    }

    // Take field
    pub fn take_rtpids_to(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rtpids_to, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryTransferRuleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_id_from)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_id_to)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rtpids_from)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rtpids_to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.session_id_from.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.session_id_from);
        }
        if !self.session_id_to.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.session_id_to);
        }
        for value in &self.rtpids_from {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.rtpids_to {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.session_id_from.is_empty() {
            os.write_string(2, &self.session_id_from)?;
        }
        if !self.session_id_to.is_empty() {
            os.write_string(3, &self.session_id_to)?;
        }
        for v in &self.rtpids_from {
            os.write_string(4, &v)?;
        };
        for v in &self.rtpids_to {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTransferRuleResponse {
        QueryTransferRuleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &QueryTransferRuleResponse| { &m.result },
                |m: &mut QueryTransferRuleResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_id_from",
                |m: &QueryTransferRuleResponse| { &m.session_id_from },
                |m: &mut QueryTransferRuleResponse| { &mut m.session_id_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_id_to",
                |m: &QueryTransferRuleResponse| { &m.session_id_to },
                |m: &mut QueryTransferRuleResponse| { &mut m.session_id_to },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpids_from",
                |m: &QueryTransferRuleResponse| { &m.rtpids_from },
                |m: &mut QueryTransferRuleResponse| { &mut m.rtpids_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpids_to",
                |m: &QueryTransferRuleResponse| { &m.rtpids_to },
                |m: &mut QueryTransferRuleResponse| { &mut m.rtpids_to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryTransferRuleResponse>(
                "QueryTransferRuleResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryTransferRuleResponse {
        static instance: ::protobuf::rt::LazyV2<QueryTransferRuleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTransferRuleResponse::new)
    }
}

impl ::protobuf::Clear for QueryTransferRuleResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.session_id_from.clear();
        self.session_id_to.clear();
        self.rtpids_from.clear();
        self.rtpids_to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryTransferRuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTransferRuleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Result {
    // message fields
    pub code: i32,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Result {
    fn default() -> &'a Result {
        <Result as ::protobuf::Message>::default_instance()
    }
}

impl Result {
    pub fn new() -> Result {
        ::std::default::Default::default()
    }

    // int32 code = 1;


    pub fn get_code(&self) -> i32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = v;
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Result {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Result {
        Result::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "code",
                |m: &Result| { &m.code },
                |m: &mut Result| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Result| { &m.description },
                |m: &mut Result| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Result>(
                "Result",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Result {
        static instance: ::protobuf::rt::LazyV2<Result> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Result::new)
    }
}

impl ::protobuf::Clear for Result {
    fn clear(&mut self) {
        self.code = 0;
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Result {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MediaDesc {
    // message fields
    pub field_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MediaDesc {
    fn default() -> &'a MediaDesc {
        <MediaDesc as ::protobuf::Message>::default_instance()
    }
}

impl MediaDesc {
    pub fn new() -> MediaDesc {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MediaDesc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MediaDesc {
        MediaDesc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &MediaDesc| { &m.field_type },
                |m: &mut MediaDesc| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MediaDesc>(
                "MediaDesc",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MediaDesc {
        static instance: ::protobuf::rt::LazyV2<MediaDesc> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MediaDesc::new)
    }
}

impl ::protobuf::Clear for MediaDesc {
    fn clear(&mut self) {
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MediaDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaDesc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferDesc {
    // message fields
    pub IP: ::std::string::String,
    pub Port: u32,
    pub enablePortMux: bool,
    pub portMuxID: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferDesc {
    fn default() -> &'a TransferDesc {
        <TransferDesc as ::protobuf::Message>::default_instance()
    }
}

impl TransferDesc {
    pub fn new() -> TransferDesc {
        ::std::default::Default::default()
    }

    // string IP = 1;


    pub fn get_IP(&self) -> &str {
        &self.IP
    }
    pub fn clear_IP(&mut self) {
        self.IP.clear();
    }

    // Param is passed by value, moved
    pub fn set_IP(&mut self, v: ::std::string::String) {
        self.IP = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_IP(&mut self) -> &mut ::std::string::String {
        &mut self.IP
    }

    // Take field
    pub fn take_IP(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.IP, ::std::string::String::new())
    }

    // uint32 Port = 2;


    pub fn get_Port(&self) -> u32 {
        self.Port
    }
    pub fn clear_Port(&mut self) {
        self.Port = 0;
    }

    // Param is passed by value, moved
    pub fn set_Port(&mut self, v: u32) {
        self.Port = v;
    }

    // bool enablePortMux = 3;


    pub fn get_enablePortMux(&self) -> bool {
        self.enablePortMux
    }
    pub fn clear_enablePortMux(&mut self) {
        self.enablePortMux = false;
    }

    // Param is passed by value, moved
    pub fn set_enablePortMux(&mut self, v: bool) {
        self.enablePortMux = v;
    }

    // uint32 portMuxID = 4;


    pub fn get_portMuxID(&self) -> u32 {
        self.portMuxID
    }
    pub fn clear_portMuxID(&mut self) {
        self.portMuxID = 0;
    }

    // Param is passed by value, moved
    pub fn set_portMuxID(&mut self, v: u32) {
        self.portMuxID = v;
    }
}

impl ::protobuf::Message for TransferDesc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.IP)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Port = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enablePortMux = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.portMuxID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.IP.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.IP);
        }
        if self.Port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.enablePortMux != false {
            my_size += 2;
        }
        if self.portMuxID != 0 {
            my_size += ::protobuf::rt::value_size(4, self.portMuxID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.IP.is_empty() {
            os.write_string(1, &self.IP)?;
        }
        if self.Port != 0 {
            os.write_uint32(2, self.Port)?;
        }
        if self.enablePortMux != false {
            os.write_bool(3, self.enablePortMux)?;
        }
        if self.portMuxID != 0 {
            os.write_uint32(4, self.portMuxID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferDesc {
        TransferDesc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "IP",
                |m: &TransferDesc| { &m.IP },
                |m: &mut TransferDesc| { &mut m.IP },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Port",
                |m: &TransferDesc| { &m.Port },
                |m: &mut TransferDesc| { &mut m.Port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enablePortMux",
                |m: &TransferDesc| { &m.enablePortMux },
                |m: &mut TransferDesc| { &mut m.enablePortMux },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "portMuxID",
                |m: &TransferDesc| { &m.portMuxID },
                |m: &mut TransferDesc| { &mut m.portMuxID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferDesc>(
                "TransferDesc",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferDesc {
        static instance: ::protobuf::rt::LazyV2<TransferDesc> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferDesc::new)
    }
}

impl ::protobuf::Clear for TransferDesc {
    fn clear(&mut self) {
        self.IP.clear();
        self.Port = 0;
        self.enablePortMux = false;
        self.portMuxID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferDesc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddChannelRequest {
    // message fields
    pub field_type: ::std::string::String,
    pub dir: ::std::string::String,
    pub endpoint_ID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddChannelRequest {
    fn default() -> &'a AddChannelRequest {
        <AddChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddChannelRequest {
    pub fn new() -> AddChannelRequest {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string dir = 2;


    pub fn get_dir(&self) -> &str {
        &self.dir
    }
    pub fn clear_dir(&mut self) {
        self.dir.clear();
    }

    // Param is passed by value, moved
    pub fn set_dir(&mut self, v: ::std::string::String) {
        self.dir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dir(&mut self) -> &mut ::std::string::String {
        &mut self.dir
    }

    // Take field
    pub fn take_dir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dir, ::std::string::String::new())
    }

    // string endpoint_ID = 3;


    pub fn get_endpoint_ID(&self) -> &str {
        &self.endpoint_ID
    }
    pub fn clear_endpoint_ID(&mut self) {
        self.endpoint_ID.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint_ID(&mut self, v: ::std::string::String) {
        self.endpoint_ID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint_ID(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint_ID
    }

    // Take field
    pub fn take_endpoint_ID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint_ID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddChannelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dir)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint_ID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        if !self.dir.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dir);
        }
        if !self.endpoint_ID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.endpoint_ID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        if !self.dir.is_empty() {
            os.write_string(2, &self.dir)?;
        }
        if !self.endpoint_ID.is_empty() {
            os.write_string(3, &self.endpoint_ID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddChannelRequest {
        AddChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &AddChannelRequest| { &m.field_type },
                |m: &mut AddChannelRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dir",
                |m: &AddChannelRequest| { &m.dir },
                |m: &mut AddChannelRequest| { &mut m.dir },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoint_ID",
                |m: &AddChannelRequest| { &m.endpoint_ID },
                |m: &mut AddChannelRequest| { &mut m.endpoint_ID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddChannelRequest>(
                "AddChannelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddChannelRequest {
        static instance: ::protobuf::rt::LazyV2<AddChannelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddChannelRequest::new)
    }
}

impl ::protobuf::Clear for AddChannelRequest {
    fn clear(&mut self) {
        self.field_type.clear();
        self.dir.clear();
        self.endpoint_ID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddChannelResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub rtpid: ::std::string::String,
    pub desc: ::protobuf::SingularPtrField<MediaDesc>,
    pub local: ::protobuf::SingularPtrField<TransferDesc>,
    pub srtp_desc: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddChannelResponse {
    fn default() -> &'a AddChannelResponse {
        <AddChannelResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddChannelResponse {
    pub fn new() -> AddChannelResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // string rtpid = 2;


    pub fn get_rtpid(&self) -> &str {
        &self.rtpid
    }
    pub fn clear_rtpid(&mut self) {
        self.rtpid.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpid(&mut self, v: ::std::string::String) {
        self.rtpid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtpid(&mut self) -> &mut ::std::string::String {
        &mut self.rtpid
    }

    // Take field
    pub fn take_rtpid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rtpid, ::std::string::String::new())
    }

    // .exchangeclient.MediaDesc desc = 3;


    pub fn get_desc(&self) -> &MediaDesc {
        self.desc.as_ref().unwrap_or_else(|| <MediaDesc as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: MediaDesc) {
        self.desc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut MediaDesc {
        if self.desc.is_none() {
            self.desc.set_default();
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> MediaDesc {
        self.desc.take().unwrap_or_else(|| MediaDesc::new())
    }

    // .exchangeclient.TransferDesc local = 4;


    pub fn get_local(&self) -> &TransferDesc {
        self.local.as_ref().unwrap_or_else(|| <TransferDesc as ::protobuf::Message>::default_instance())
    }
    pub fn clear_local(&mut self) {
        self.local.clear();
    }

    pub fn has_local(&self) -> bool {
        self.local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: TransferDesc) {
        self.local = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local(&mut self) -> &mut TransferDesc {
        if self.local.is_none() {
            self.local.set_default();
        }
        self.local.as_mut().unwrap()
    }

    // Take field
    pub fn take_local(&mut self) -> TransferDesc {
        self.local.take().unwrap_or_else(|| TransferDesc::new())
    }

    // string srtp_desc = 5;


    pub fn get_srtp_desc(&self) -> &str {
        &self.srtp_desc
    }
    pub fn clear_srtp_desc(&mut self) {
        self.srtp_desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_srtp_desc(&mut self, v: ::std::string::String) {
        self.srtp_desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_srtp_desc(&mut self) -> &mut ::std::string::String {
        &mut self.srtp_desc
    }

    // Take field
    pub fn take_srtp_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.srtp_desc, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddChannelResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rtpid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desc)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.srtp_desc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.rtpid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.rtpid);
        }
        if let Some(ref v) = self.desc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.local.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.srtp_desc.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.srtp_desc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.rtpid.is_empty() {
            os.write_string(2, &self.rtpid)?;
        }
        if let Some(ref v) = self.desc.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.local.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.srtp_desc.is_empty() {
            os.write_string(5, &self.srtp_desc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddChannelResponse {
        AddChannelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &AddChannelResponse| { &m.result },
                |m: &mut AddChannelResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpid",
                |m: &AddChannelResponse| { &m.rtpid },
                |m: &mut AddChannelResponse| { &mut m.rtpid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MediaDesc>>(
                "desc",
                |m: &AddChannelResponse| { &m.desc },
                |m: &mut AddChannelResponse| { &mut m.desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransferDesc>>(
                "local",
                |m: &AddChannelResponse| { &m.local },
                |m: &mut AddChannelResponse| { &mut m.local },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "srtp_desc",
                |m: &AddChannelResponse| { &m.srtp_desc },
                |m: &mut AddChannelResponse| { &mut m.srtp_desc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddChannelResponse>(
                "AddChannelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddChannelResponse {
        static instance: ::protobuf::rt::LazyV2<AddChannelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddChannelResponse::new)
    }
}

impl ::protobuf::Clear for AddChannelResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.rtpid.clear();
        self.desc.clear();
        self.local.clear();
        self.srtp_desc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddChannelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddChannelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateMediaChannelRequest {
    // message fields
    pub rtpid: ::std::string::String,
    pub remote_transfer_desc: ::protobuf::SingularPtrField<TransferDesc>,
    pub srtp_desc: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateMediaChannelRequest {
    fn default() -> &'a UpdateMediaChannelRequest {
        <UpdateMediaChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateMediaChannelRequest {
    pub fn new() -> UpdateMediaChannelRequest {
        ::std::default::Default::default()
    }

    // string rtpid = 1;


    pub fn get_rtpid(&self) -> &str {
        &self.rtpid
    }
    pub fn clear_rtpid(&mut self) {
        self.rtpid.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpid(&mut self, v: ::std::string::String) {
        self.rtpid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtpid(&mut self) -> &mut ::std::string::String {
        &mut self.rtpid
    }

    // Take field
    pub fn take_rtpid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rtpid, ::std::string::String::new())
    }

    // .exchangeclient.TransferDesc remote_transfer_desc = 2;


    pub fn get_remote_transfer_desc(&self) -> &TransferDesc {
        self.remote_transfer_desc.as_ref().unwrap_or_else(|| <TransferDesc as ::protobuf::Message>::default_instance())
    }
    pub fn clear_remote_transfer_desc(&mut self) {
        self.remote_transfer_desc.clear();
    }

    pub fn has_remote_transfer_desc(&self) -> bool {
        self.remote_transfer_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_transfer_desc(&mut self, v: TransferDesc) {
        self.remote_transfer_desc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_transfer_desc(&mut self) -> &mut TransferDesc {
        if self.remote_transfer_desc.is_none() {
            self.remote_transfer_desc.set_default();
        }
        self.remote_transfer_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_transfer_desc(&mut self) -> TransferDesc {
        self.remote_transfer_desc.take().unwrap_or_else(|| TransferDesc::new())
    }

    // string srtp_desc = 3;


    pub fn get_srtp_desc(&self) -> &str {
        &self.srtp_desc
    }
    pub fn clear_srtp_desc(&mut self) {
        self.srtp_desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_srtp_desc(&mut self, v: ::std::string::String) {
        self.srtp_desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_srtp_desc(&mut self) -> &mut ::std::string::String {
        &mut self.srtp_desc
    }

    // Take field
    pub fn take_srtp_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.srtp_desc, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateMediaChannelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.remote_transfer_desc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rtpid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remote_transfer_desc)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.srtp_desc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.rtpid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rtpid);
        }
        if let Some(ref v) = self.remote_transfer_desc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.srtp_desc.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.srtp_desc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.rtpid.is_empty() {
            os.write_string(1, &self.rtpid)?;
        }
        if let Some(ref v) = self.remote_transfer_desc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.srtp_desc.is_empty() {
            os.write_string(3, &self.srtp_desc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateMediaChannelRequest {
        UpdateMediaChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpid",
                |m: &UpdateMediaChannelRequest| { &m.rtpid },
                |m: &mut UpdateMediaChannelRequest| { &mut m.rtpid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransferDesc>>(
                "remote_transfer_desc",
                |m: &UpdateMediaChannelRequest| { &m.remote_transfer_desc },
                |m: &mut UpdateMediaChannelRequest| { &mut m.remote_transfer_desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "srtp_desc",
                |m: &UpdateMediaChannelRequest| { &m.srtp_desc },
                |m: &mut UpdateMediaChannelRequest| { &mut m.srtp_desc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateMediaChannelRequest>(
                "UpdateMediaChannelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateMediaChannelRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateMediaChannelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateMediaChannelRequest::new)
    }
}

impl ::protobuf::Clear for UpdateMediaChannelRequest {
    fn clear(&mut self) {
        self.rtpid.clear();
        self.remote_transfer_desc.clear();
        self.srtp_desc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateMediaChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateMediaChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateMediaChannelResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub rtpid: ::std::string::String,
    pub desc: ::protobuf::SingularPtrField<MediaDesc>,
    pub local_transfer_desc: ::protobuf::SingularPtrField<TransferDesc>,
    pub remote_transfer_desc: ::protobuf::SingularPtrField<TransferDesc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateMediaChannelResponse {
    fn default() -> &'a UpdateMediaChannelResponse {
        <UpdateMediaChannelResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateMediaChannelResponse {
    pub fn new() -> UpdateMediaChannelResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // string rtpid = 2;


    pub fn get_rtpid(&self) -> &str {
        &self.rtpid
    }
    pub fn clear_rtpid(&mut self) {
        self.rtpid.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpid(&mut self, v: ::std::string::String) {
        self.rtpid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtpid(&mut self) -> &mut ::std::string::String {
        &mut self.rtpid
    }

    // Take field
    pub fn take_rtpid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rtpid, ::std::string::String::new())
    }

    // .exchangeclient.MediaDesc desc = 3;


    pub fn get_desc(&self) -> &MediaDesc {
        self.desc.as_ref().unwrap_or_else(|| <MediaDesc as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: MediaDesc) {
        self.desc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut MediaDesc {
        if self.desc.is_none() {
            self.desc.set_default();
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> MediaDesc {
        self.desc.take().unwrap_or_else(|| MediaDesc::new())
    }

    // .exchangeclient.TransferDesc local_transfer_desc = 4;


    pub fn get_local_transfer_desc(&self) -> &TransferDesc {
        self.local_transfer_desc.as_ref().unwrap_or_else(|| <TransferDesc as ::protobuf::Message>::default_instance())
    }
    pub fn clear_local_transfer_desc(&mut self) {
        self.local_transfer_desc.clear();
    }

    pub fn has_local_transfer_desc(&self) -> bool {
        self.local_transfer_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_transfer_desc(&mut self, v: TransferDesc) {
        self.local_transfer_desc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_transfer_desc(&mut self) -> &mut TransferDesc {
        if self.local_transfer_desc.is_none() {
            self.local_transfer_desc.set_default();
        }
        self.local_transfer_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_transfer_desc(&mut self) -> TransferDesc {
        self.local_transfer_desc.take().unwrap_or_else(|| TransferDesc::new())
    }

    // .exchangeclient.TransferDesc remote_transfer_desc = 5;


    pub fn get_remote_transfer_desc(&self) -> &TransferDesc {
        self.remote_transfer_desc.as_ref().unwrap_or_else(|| <TransferDesc as ::protobuf::Message>::default_instance())
    }
    pub fn clear_remote_transfer_desc(&mut self) {
        self.remote_transfer_desc.clear();
    }

    pub fn has_remote_transfer_desc(&self) -> bool {
        self.remote_transfer_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_transfer_desc(&mut self, v: TransferDesc) {
        self.remote_transfer_desc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_transfer_desc(&mut self) -> &mut TransferDesc {
        if self.remote_transfer_desc.is_none() {
            self.remote_transfer_desc.set_default();
        }
        self.remote_transfer_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_transfer_desc(&mut self) -> TransferDesc {
        self.remote_transfer_desc.take().unwrap_or_else(|| TransferDesc::new())
    }
}

impl ::protobuf::Message for UpdateMediaChannelResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local_transfer_desc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remote_transfer_desc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rtpid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desc)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_transfer_desc)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remote_transfer_desc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.rtpid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.rtpid);
        }
        if let Some(ref v) = self.desc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.local_transfer_desc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.remote_transfer_desc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.rtpid.is_empty() {
            os.write_string(2, &self.rtpid)?;
        }
        if let Some(ref v) = self.desc.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.local_transfer_desc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.remote_transfer_desc.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateMediaChannelResponse {
        UpdateMediaChannelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &UpdateMediaChannelResponse| { &m.result },
                |m: &mut UpdateMediaChannelResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpid",
                |m: &UpdateMediaChannelResponse| { &m.rtpid },
                |m: &mut UpdateMediaChannelResponse| { &mut m.rtpid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MediaDesc>>(
                "desc",
                |m: &UpdateMediaChannelResponse| { &m.desc },
                |m: &mut UpdateMediaChannelResponse| { &mut m.desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransferDesc>>(
                "local_transfer_desc",
                |m: &UpdateMediaChannelResponse| { &m.local_transfer_desc },
                |m: &mut UpdateMediaChannelResponse| { &mut m.local_transfer_desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransferDesc>>(
                "remote_transfer_desc",
                |m: &UpdateMediaChannelResponse| { &m.remote_transfer_desc },
                |m: &mut UpdateMediaChannelResponse| { &mut m.remote_transfer_desc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateMediaChannelResponse>(
                "UpdateMediaChannelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateMediaChannelResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateMediaChannelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateMediaChannelResponse::new)
    }
}

impl ::protobuf::Clear for UpdateMediaChannelResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.rtpid.clear();
        self.desc.clear();
        self.local_transfer_desc.clear();
        self.remote_transfer_desc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateMediaChannelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateMediaChannelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteMediaChannelRequst {
    // message fields
    pub rtpid: ::std::string::String,
    pub bForce: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteMediaChannelRequst {
    fn default() -> &'a DeleteMediaChannelRequst {
        <DeleteMediaChannelRequst as ::protobuf::Message>::default_instance()
    }
}

impl DeleteMediaChannelRequst {
    pub fn new() -> DeleteMediaChannelRequst {
        ::std::default::Default::default()
    }

    // string rtpid = 1;


    pub fn get_rtpid(&self) -> &str {
        &self.rtpid
    }
    pub fn clear_rtpid(&mut self) {
        self.rtpid.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpid(&mut self, v: ::std::string::String) {
        self.rtpid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtpid(&mut self) -> &mut ::std::string::String {
        &mut self.rtpid
    }

    // Take field
    pub fn take_rtpid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rtpid, ::std::string::String::new())
    }

    // bool bForce = 2;


    pub fn get_bForce(&self) -> bool {
        self.bForce
    }
    pub fn clear_bForce(&mut self) {
        self.bForce = false;
    }

    // Param is passed by value, moved
    pub fn set_bForce(&mut self, v: bool) {
        self.bForce = v;
    }
}

impl ::protobuf::Message for DeleteMediaChannelRequst {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rtpid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bForce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.rtpid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rtpid);
        }
        if self.bForce != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.rtpid.is_empty() {
            os.write_string(1, &self.rtpid)?;
        }
        if self.bForce != false {
            os.write_bool(2, self.bForce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteMediaChannelRequst {
        DeleteMediaChannelRequst::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpid",
                |m: &DeleteMediaChannelRequst| { &m.rtpid },
                |m: &mut DeleteMediaChannelRequst| { &mut m.rtpid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bForce",
                |m: &DeleteMediaChannelRequst| { &m.bForce },
                |m: &mut DeleteMediaChannelRequst| { &mut m.bForce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteMediaChannelRequst>(
                "DeleteMediaChannelRequst",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteMediaChannelRequst {
        static instance: ::protobuf::rt::LazyV2<DeleteMediaChannelRequst> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteMediaChannelRequst::new)
    }
}

impl ::protobuf::Clear for DeleteMediaChannelRequst {
    fn clear(&mut self) {
        self.rtpid.clear();
        self.bForce = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteMediaChannelRequst {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteMediaChannelRequst {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteMediaChannelResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub srcs: ::protobuf::RepeatedField<::std::string::String>,
    pub dsts: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteMediaChannelResponse {
    fn default() -> &'a DeleteMediaChannelResponse {
        <DeleteMediaChannelResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteMediaChannelResponse {
    pub fn new() -> DeleteMediaChannelResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // repeated string srcs = 2;


    pub fn get_srcs(&self) -> &[::std::string::String] {
        &self.srcs
    }
    pub fn clear_srcs(&mut self) {
        self.srcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_srcs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.srcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_srcs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.srcs
    }

    // Take field
    pub fn take_srcs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.srcs, ::protobuf::RepeatedField::new())
    }

    // repeated string dsts = 3;


    pub fn get_dsts(&self) -> &[::std::string::String] {
        &self.dsts
    }
    pub fn clear_dsts(&mut self) {
        self.dsts.clear();
    }

    // Param is passed by value, moved
    pub fn set_dsts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dsts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dsts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dsts
    }

    // Take field
    pub fn take_dsts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dsts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteMediaChannelResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.srcs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dsts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.srcs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.dsts {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.srcs {
            os.write_string(2, &v)?;
        };
        for v in &self.dsts {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteMediaChannelResponse {
        DeleteMediaChannelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &DeleteMediaChannelResponse| { &m.result },
                |m: &mut DeleteMediaChannelResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "srcs",
                |m: &DeleteMediaChannelResponse| { &m.srcs },
                |m: &mut DeleteMediaChannelResponse| { &mut m.srcs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dsts",
                |m: &DeleteMediaChannelResponse| { &m.dsts },
                |m: &mut DeleteMediaChannelResponse| { &mut m.dsts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteMediaChannelResponse>(
                "DeleteMediaChannelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteMediaChannelResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteMediaChannelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteMediaChannelResponse::new)
    }
}

impl ::protobuf::Clear for DeleteMediaChannelResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.srcs.clear();
        self.dsts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteMediaChannelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteMediaChannelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferRule {
    // message fields
    pub from: ::std::string::String,
    pub to: ::std::string::String,
    pub bAdd: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferRule {
    fn default() -> &'a TransferRule {
        <TransferRule as ::protobuf::Message>::default_instance()
    }
}

impl TransferRule {
    pub fn new() -> TransferRule {
        ::std::default::Default::default()
    }

    // string from = 1;


    pub fn get_from(&self) -> &str {
        &self.from
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::string::String) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::string::String {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from, ::std::string::String::new())
    }

    // string to = 2;


    pub fn get_to(&self) -> &str {
        &self.to
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::string::String) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::string::String {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.to, ::std::string::String::new())
    }

    // bool bAdd = 3;


    pub fn get_bAdd(&self) -> bool {
        self.bAdd
    }
    pub fn clear_bAdd(&mut self) {
        self.bAdd = false;
    }

    // Param is passed by value, moved
    pub fn set_bAdd(&mut self, v: bool) {
        self.bAdd = v;
    }
}

impl ::protobuf::Message for TransferRule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.to)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bAdd = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.to);
        }
        if self.bAdd != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_string(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_string(2, &self.to)?;
        }
        if self.bAdd != false {
            os.write_bool(3, self.bAdd)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferRule {
        TransferRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from",
                |m: &TransferRule| { &m.from },
                |m: &mut TransferRule| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "to",
                |m: &TransferRule| { &m.to },
                |m: &mut TransferRule| { &mut m.to },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bAdd",
                |m: &TransferRule| { &m.bAdd },
                |m: &mut TransferRule| { &mut m.bAdd },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferRule>(
                "TransferRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferRule {
        static instance: ::protobuf::rt::LazyV2<TransferRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferRule::new)
    }
}

impl ::protobuf::Clear for TransferRule {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.bAdd = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetTransferRuleRequest {
    // message fields
    pub rules: ::protobuf::RepeatedField<TransferRule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetTransferRuleRequest {
    fn default() -> &'a SetTransferRuleRequest {
        <SetTransferRuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetTransferRuleRequest {
    pub fn new() -> SetTransferRuleRequest {
        ::std::default::Default::default()
    }

    // repeated .exchangeclient.TransferRule rules = 1;


    pub fn get_rules(&self) -> &[TransferRule] {
        &self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::protobuf::RepeatedField<TransferRule>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::protobuf::RepeatedField<TransferRule> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::protobuf::RepeatedField<TransferRule> {
        ::std::mem::replace(&mut self.rules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SetTransferRuleRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rules {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetTransferRuleRequest {
        SetTransferRuleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransferRule>>(
                "rules",
                |m: &SetTransferRuleRequest| { &m.rules },
                |m: &mut SetTransferRuleRequest| { &mut m.rules },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetTransferRuleRequest>(
                "SetTransferRuleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetTransferRuleRequest {
        static instance: ::protobuf::rt::LazyV2<SetTransferRuleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetTransferRuleRequest::new)
    }
}

impl ::protobuf::Clear for SetTransferRuleRequest {
    fn clear(&mut self) {
        self.rules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetTransferRuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetTransferRuleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelInfo {
    // message fields
    pub desc: ::protobuf::SingularPtrField<MediaDesc>,
    pub local_transfer_desc: ::protobuf::SingularPtrField<TransferDesc>,
    pub remote_transfer_desc: ::protobuf::SingularPtrField<TransferDesc>,
    pub bConnected: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelInfo {
    fn default() -> &'a ChannelInfo {
        <ChannelInfo as ::protobuf::Message>::default_instance()
    }
}

impl ChannelInfo {
    pub fn new() -> ChannelInfo {
        ::std::default::Default::default()
    }

    // .exchangeclient.MediaDesc desc = 1;


    pub fn get_desc(&self) -> &MediaDesc {
        self.desc.as_ref().unwrap_or_else(|| <MediaDesc as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: MediaDesc) {
        self.desc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut MediaDesc {
        if self.desc.is_none() {
            self.desc.set_default();
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> MediaDesc {
        self.desc.take().unwrap_or_else(|| MediaDesc::new())
    }

    // .exchangeclient.TransferDesc local_transfer_desc = 2;


    pub fn get_local_transfer_desc(&self) -> &TransferDesc {
        self.local_transfer_desc.as_ref().unwrap_or_else(|| <TransferDesc as ::protobuf::Message>::default_instance())
    }
    pub fn clear_local_transfer_desc(&mut self) {
        self.local_transfer_desc.clear();
    }

    pub fn has_local_transfer_desc(&self) -> bool {
        self.local_transfer_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_transfer_desc(&mut self, v: TransferDesc) {
        self.local_transfer_desc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_transfer_desc(&mut self) -> &mut TransferDesc {
        if self.local_transfer_desc.is_none() {
            self.local_transfer_desc.set_default();
        }
        self.local_transfer_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_transfer_desc(&mut self) -> TransferDesc {
        self.local_transfer_desc.take().unwrap_or_else(|| TransferDesc::new())
    }

    // .exchangeclient.TransferDesc remote_transfer_desc = 3;


    pub fn get_remote_transfer_desc(&self) -> &TransferDesc {
        self.remote_transfer_desc.as_ref().unwrap_or_else(|| <TransferDesc as ::protobuf::Message>::default_instance())
    }
    pub fn clear_remote_transfer_desc(&mut self) {
        self.remote_transfer_desc.clear();
    }

    pub fn has_remote_transfer_desc(&self) -> bool {
        self.remote_transfer_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_transfer_desc(&mut self, v: TransferDesc) {
        self.remote_transfer_desc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_transfer_desc(&mut self) -> &mut TransferDesc {
        if self.remote_transfer_desc.is_none() {
            self.remote_transfer_desc.set_default();
        }
        self.remote_transfer_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_transfer_desc(&mut self) -> TransferDesc {
        self.remote_transfer_desc.take().unwrap_or_else(|| TransferDesc::new())
    }

    // bool bConnected = 4;


    pub fn get_bConnected(&self) -> bool {
        self.bConnected
    }
    pub fn clear_bConnected(&mut self) {
        self.bConnected = false;
    }

    // Param is passed by value, moved
    pub fn set_bConnected(&mut self, v: bool) {
        self.bConnected = v;
    }
}

impl ::protobuf::Message for ChannelInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.desc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local_transfer_desc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remote_transfer_desc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desc)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_transfer_desc)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remote_transfer_desc)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bConnected = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.desc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.local_transfer_desc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.remote_transfer_desc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.bConnected != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.desc.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.local_transfer_desc.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.remote_transfer_desc.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.bConnected != false {
            os.write_bool(4, self.bConnected)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelInfo {
        ChannelInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MediaDesc>>(
                "desc",
                |m: &ChannelInfo| { &m.desc },
                |m: &mut ChannelInfo| { &mut m.desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransferDesc>>(
                "local_transfer_desc",
                |m: &ChannelInfo| { &m.local_transfer_desc },
                |m: &mut ChannelInfo| { &mut m.local_transfer_desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransferDesc>>(
                "remote_transfer_desc",
                |m: &ChannelInfo| { &m.remote_transfer_desc },
                |m: &mut ChannelInfo| { &mut m.remote_transfer_desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bConnected",
                |m: &ChannelInfo| { &m.bConnected },
                |m: &mut ChannelInfo| { &mut m.bConnected },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelInfo>(
                "ChannelInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelInfo {
        static instance: ::protobuf::rt::LazyV2<ChannelInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelInfo::new)
    }
}

impl ::protobuf::Clear for ChannelInfo {
    fn clear(&mut self) {
        self.desc.clear();
        self.local_transfer_desc.clear();
        self.remote_transfer_desc.clear();
        self.bConnected = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryChannelRequest {
    // message fields
    pub rtpid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryChannelRequest {
    fn default() -> &'a QueryChannelRequest {
        <QueryChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryChannelRequest {
    pub fn new() -> QueryChannelRequest {
        ::std::default::Default::default()
    }

    // string rtpid = 1;


    pub fn get_rtpid(&self) -> &str {
        &self.rtpid
    }
    pub fn clear_rtpid(&mut self) {
        self.rtpid.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpid(&mut self, v: ::std::string::String) {
        self.rtpid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtpid(&mut self) -> &mut ::std::string::String {
        &mut self.rtpid
    }

    // Take field
    pub fn take_rtpid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rtpid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryChannelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rtpid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.rtpid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rtpid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.rtpid.is_empty() {
            os.write_string(1, &self.rtpid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryChannelRequest {
        QueryChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpid",
                |m: &QueryChannelRequest| { &m.rtpid },
                |m: &mut QueryChannelRequest| { &mut m.rtpid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryChannelRequest>(
                "QueryChannelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryChannelRequest {
        static instance: ::protobuf::rt::LazyV2<QueryChannelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryChannelRequest::new)
    }
}

impl ::protobuf::Clear for QueryChannelRequest {
    fn clear(&mut self) {
        self.rtpid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryChannelResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub infos: ::protobuf::RepeatedField<ChannelInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryChannelResponse {
    fn default() -> &'a QueryChannelResponse {
        <QueryChannelResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryChannelResponse {
    pub fn new() -> QueryChannelResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // repeated .exchangeclient.ChannelInfo infos = 2;


    pub fn get_infos(&self) -> &[ChannelInfo] {
        &self.infos
    }
    pub fn clear_infos(&mut self) {
        self.infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_infos(&mut self, v: ::protobuf::RepeatedField<ChannelInfo>) {
        self.infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_infos(&mut self) -> &mut ::protobuf::RepeatedField<ChannelInfo> {
        &mut self.infos
    }

    // Take field
    pub fn take_infos(&mut self) -> ::protobuf::RepeatedField<ChannelInfo> {
        ::std::mem::replace(&mut self.infos, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryChannelResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.infos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.infos {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryChannelResponse {
        QueryChannelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &QueryChannelResponse| { &m.result },
                |m: &mut QueryChannelResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelInfo>>(
                "infos",
                |m: &QueryChannelResponse| { &m.infos },
                |m: &mut QueryChannelResponse| { &mut m.infos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryChannelResponse>(
                "QueryChannelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryChannelResponse {
        static instance: ::protobuf::rt::LazyV2<QueryChannelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryChannelResponse::new)
    }
}

impl ::protobuf::Clear for QueryChannelResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.infos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryChannelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryChannelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuerySrcByConsumerRequest {
    // message fields
    pub rtpid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySrcByConsumerRequest {
    fn default() -> &'a QuerySrcByConsumerRequest {
        <QuerySrcByConsumerRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySrcByConsumerRequest {
    pub fn new() -> QuerySrcByConsumerRequest {
        ::std::default::Default::default()
    }

    // string rtpid = 1;


    pub fn get_rtpid(&self) -> &str {
        &self.rtpid
    }
    pub fn clear_rtpid(&mut self) {
        self.rtpid.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpid(&mut self, v: ::std::string::String) {
        self.rtpid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtpid(&mut self) -> &mut ::std::string::String {
        &mut self.rtpid
    }

    // Take field
    pub fn take_rtpid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rtpid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySrcByConsumerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rtpid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.rtpid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rtpid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.rtpid.is_empty() {
            os.write_string(1, &self.rtpid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySrcByConsumerRequest {
        QuerySrcByConsumerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpid",
                |m: &QuerySrcByConsumerRequest| { &m.rtpid },
                |m: &mut QuerySrcByConsumerRequest| { &mut m.rtpid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuerySrcByConsumerRequest>(
                "QuerySrcByConsumerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySrcByConsumerRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySrcByConsumerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySrcByConsumerRequest::new)
    }
}

impl ::protobuf::Clear for QuerySrcByConsumerRequest {
    fn clear(&mut self) {
        self.rtpid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySrcByConsumerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySrcByConsumerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuerySrcByConsumerResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub rtpid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySrcByConsumerResponse {
    fn default() -> &'a QuerySrcByConsumerResponse {
        <QuerySrcByConsumerResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySrcByConsumerResponse {
    pub fn new() -> QuerySrcByConsumerResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // string rtpid = 2;


    pub fn get_rtpid(&self) -> &str {
        &self.rtpid
    }
    pub fn clear_rtpid(&mut self) {
        self.rtpid.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpid(&mut self, v: ::std::string::String) {
        self.rtpid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtpid(&mut self) -> &mut ::std::string::String {
        &mut self.rtpid
    }

    // Take field
    pub fn take_rtpid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rtpid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySrcByConsumerResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rtpid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.rtpid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.rtpid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.rtpid.is_empty() {
            os.write_string(2, &self.rtpid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySrcByConsumerResponse {
        QuerySrcByConsumerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &QuerySrcByConsumerResponse| { &m.result },
                |m: &mut QuerySrcByConsumerResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpid",
                |m: &QuerySrcByConsumerResponse| { &m.rtpid },
                |m: &mut QuerySrcByConsumerResponse| { &mut m.rtpid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuerySrcByConsumerResponse>(
                "QuerySrcByConsumerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySrcByConsumerResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySrcByConsumerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySrcByConsumerResponse::new)
    }
}

impl ::protobuf::Clear for QuerySrcByConsumerResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.rtpid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySrcByConsumerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySrcByConsumerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryConsumersBySrcRequest {
    // message fields
    pub rtpid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryConsumersBySrcRequest {
    fn default() -> &'a QueryConsumersBySrcRequest {
        <QueryConsumersBySrcRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryConsumersBySrcRequest {
    pub fn new() -> QueryConsumersBySrcRequest {
        ::std::default::Default::default()
    }

    // string rtpid = 1;


    pub fn get_rtpid(&self) -> &str {
        &self.rtpid
    }
    pub fn clear_rtpid(&mut self) {
        self.rtpid.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpid(&mut self, v: ::std::string::String) {
        self.rtpid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtpid(&mut self) -> &mut ::std::string::String {
        &mut self.rtpid
    }

    // Take field
    pub fn take_rtpid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rtpid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryConsumersBySrcRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rtpid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.rtpid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rtpid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.rtpid.is_empty() {
            os.write_string(1, &self.rtpid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryConsumersBySrcRequest {
        QueryConsumersBySrcRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpid",
                |m: &QueryConsumersBySrcRequest| { &m.rtpid },
                |m: &mut QueryConsumersBySrcRequest| { &mut m.rtpid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryConsumersBySrcRequest>(
                "QueryConsumersBySrcRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryConsumersBySrcRequest {
        static instance: ::protobuf::rt::LazyV2<QueryConsumersBySrcRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryConsumersBySrcRequest::new)
    }
}

impl ::protobuf::Clear for QueryConsumersBySrcRequest {
    fn clear(&mut self) {
        self.rtpid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryConsumersBySrcRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryConsumersBySrcRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryConsumersBySrcResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub rtpids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryConsumersBySrcResponse {
    fn default() -> &'a QueryConsumersBySrcResponse {
        <QueryConsumersBySrcResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryConsumersBySrcResponse {
    pub fn new() -> QueryConsumersBySrcResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // repeated string rtpids = 2;


    pub fn get_rtpids(&self) -> &[::std::string::String] {
        &self.rtpids
    }
    pub fn clear_rtpids(&mut self) {
        self.rtpids.clear();
    }

    // Param is passed by value, moved
    pub fn set_rtpids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rtpids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rtpids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rtpids
    }

    // Take field
    pub fn take_rtpids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rtpids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryConsumersBySrcResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rtpids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.rtpids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.rtpids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryConsumersBySrcResponse {
        QueryConsumersBySrcResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &QueryConsumersBySrcResponse| { &m.result },
                |m: &mut QueryConsumersBySrcResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rtpids",
                |m: &QueryConsumersBySrcResponse| { &m.rtpids },
                |m: &mut QueryConsumersBySrcResponse| { &mut m.rtpids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryConsumersBySrcResponse>(
                "QueryConsumersBySrcResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryConsumersBySrcResponse {
        static instance: ::protobuf::rt::LazyV2<QueryConsumersBySrcResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryConsumersBySrcResponse::new)
    }
}

impl ::protobuf::Clear for QueryConsumersBySrcResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.rtpids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryConsumersBySrcResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryConsumersBySrcResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferPair {
    // message fields
    pub from: ::std::string::String,
    pub to: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferPair {
    fn default() -> &'a TransferPair {
        <TransferPair as ::protobuf::Message>::default_instance()
    }
}

impl TransferPair {
    pub fn new() -> TransferPair {
        ::std::default::Default::default()
    }

    // string from = 1;


    pub fn get_from(&self) -> &str {
        &self.from
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::string::String) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::string::String {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from, ::std::string::String::new())
    }

    // string to = 2;


    pub fn get_to(&self) -> &str {
        &self.to
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::string::String) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::string::String {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.to, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TransferPair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.to);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_string(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_string(2, &self.to)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferPair {
        TransferPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from",
                |m: &TransferPair| { &m.from },
                |m: &mut TransferPair| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "to",
                |m: &TransferPair| { &m.to },
                |m: &mut TransferPair| { &mut m.to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferPair>(
                "TransferPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferPair {
        static instance: ::protobuf::rt::LazyV2<TransferPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferPair::new)
    }
}

impl ::protobuf::Clear for TransferPair {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAllRelationsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAllRelationsRequest {
    fn default() -> &'a QueryAllRelationsRequest {
        <QueryAllRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAllRelationsRequest {
    pub fn new() -> QueryAllRelationsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryAllRelationsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAllRelationsRequest {
        QueryAllRelationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAllRelationsRequest>(
                "QueryAllRelationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAllRelationsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAllRelationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAllRelationsRequest::new)
    }
}

impl ::protobuf::Clear for QueryAllRelationsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAllRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAllRelationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAllRelationsResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<Result>,
    pub relations: ::protobuf::RepeatedField<TransferPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAllRelationsResponse {
    fn default() -> &'a QueryAllRelationsResponse {
        <QueryAllRelationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAllRelationsResponse {
    pub fn new() -> QueryAllRelationsResponse {
        ::std::default::Default::default()
    }

    // .exchangeclient.Result result = 1;


    pub fn get_result(&self) -> &Result {
        self.result.as_ref().unwrap_or_else(|| <Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Result {
        self.result.take().unwrap_or_else(|| Result::new())
    }

    // repeated .exchangeclient.TransferPair relations = 2;


    pub fn get_relations(&self) -> &[TransferPair] {
        &self.relations
    }
    pub fn clear_relations(&mut self) {
        self.relations.clear();
    }

    // Param is passed by value, moved
    pub fn set_relations(&mut self, v: ::protobuf::RepeatedField<TransferPair>) {
        self.relations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relations(&mut self) -> &mut ::protobuf::RepeatedField<TransferPair> {
        &mut self.relations
    }

    // Take field
    pub fn take_relations(&mut self) -> ::protobuf::RepeatedField<TransferPair> {
        ::std::mem::replace(&mut self.relations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryAllRelationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.relations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAllRelationsResponse {
        QueryAllRelationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Result>>(
                "result",
                |m: &QueryAllRelationsResponse| { &m.result },
                |m: &mut QueryAllRelationsResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransferPair>>(
                "relations",
                |m: &QueryAllRelationsResponse| { &m.relations },
                |m: &mut QueryAllRelationsResponse| { &mut m.relations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryAllRelationsResponse>(
                "QueryAllRelationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryAllRelationsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAllRelationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAllRelationsResponse::new)
    }
}

impl ::protobuf::Clear for QueryAllRelationsResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.relations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAllRelationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAllRelationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EMediaType {
    MEDIA_TYPE_NONE = 0,
    AUDIO = 1,
    VIDEO = 2,
    AVBOTH = 3,
}

impl ::protobuf::ProtobufEnum for EMediaType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMediaType> {
        match value {
            0 => ::std::option::Option::Some(EMediaType::MEDIA_TYPE_NONE),
            1 => ::std::option::Option::Some(EMediaType::AUDIO),
            2 => ::std::option::Option::Some(EMediaType::VIDEO),
            3 => ::std::option::Option::Some(EMediaType::AVBOTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EMediaType] = &[
            EMediaType::MEDIA_TYPE_NONE,
            EMediaType::AUDIO,
            EMediaType::VIDEO,
            EMediaType::AVBOTH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EMediaType>("EMediaType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EMediaType {
}

impl ::std::default::Default for EMediaType {
    fn default() -> Self {
        EMediaType::MEDIA_TYPE_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for EMediaType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EMediaDirection {
    DIRNONE = 0,
    SENDONLY = 1,
    RECVONLY = 2,
    SENDRECV = 3,
}

impl ::protobuf::ProtobufEnum for EMediaDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMediaDirection> {
        match value {
            0 => ::std::option::Option::Some(EMediaDirection::DIRNONE),
            1 => ::std::option::Option::Some(EMediaDirection::SENDONLY),
            2 => ::std::option::Option::Some(EMediaDirection::RECVONLY),
            3 => ::std::option::Option::Some(EMediaDirection::SENDRECV),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EMediaDirection] = &[
            EMediaDirection::DIRNONE,
            EMediaDirection::SENDONLY,
            EMediaDirection::RECVONLY,
            EMediaDirection::SENDRECV,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EMediaDirection>("EMediaDirection", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EMediaDirection {
}

impl ::std::default::Default for EMediaDirection {
    fn default() -> Self {
        EMediaDirection::DIRNONE
    }
}

impl ::protobuf::reflect::ProtobufValue for EMediaDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13MediaTransfer.proto\x12\x0eexchangeclient\"O\n\x11AddSessionReques\
    t\x12\x1d\n\nsession_id\x18\x01\x20\x01(\tR\tsessionId\x12\x1b\n\tlocal_\
    sdp\x18\x02\x20\x01(\tR\x08localSdp\"a\n\x12AddSessionResponse\x12.\n\
    \x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclient.ResultR\x06result\
    \x12\x1b\n\tlocal_sdp\x18\x02\x20\x01(\tR\x08localSdp\"b\n\x14UpdateSess\
    ionRequest\x12\x1d\n\nsession_id\x18\x01\x20\x01(\tR\tsessionId\x12\x19\
    \n\x08is_local\x18\x02\x20\x01(\x08R\x07isLocal\x12\x10\n\x03sdp\x18\x03\
    \x20\x01(\tR\x03sdp\"Y\n\x15UpdateSessionResponse\x12.\n\x06result\x18\
    \x01\x20\x01(\x0b2\x16.exchangeclient.ResultR\x06result\x12\x10\n\x03sdp\
    \x18\x02\x20\x01(\tR\x03sdp\"5\n\x14DeleteSessionRequest\x12\x1d\n\nsess\
    ion_id\x18\x01\x20\x01(\tR\tsessionId\"G\n\x15DeleteSessionResponse\x12.\
    \n\x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclient.ResultR\x06result\
    \"\xbb\x01\n\x16AddTransferRuleRequest\x12\x17\n\x07rule_id\x18\x01\x20\
    \x01(\tR\x06ruleId\x12&\n\x0fsession_id_from\x18\x02\x20\x01(\tR\rsessio\
    nIdFrom\x12\"\n\rsession_id_to\x18\x03\x20\x01(\tR\x0bsessionIdTo\x12\
    \x1f\n\x0brtpids_from\x18\x04\x20\x03(\tR\nrtpidsFrom\x12\x1b\n\trtpids_\
    to\x18\x05\x20\x03(\tR\x08rtpidsTo\"\x87\x01\n\x17AddTransferRuleRespons\
    e\x12.\n\x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclient.ResultR\x06r\
    esult\x12\x1f\n\x0brtpids_from\x18\x02\x20\x03(\tR\nrtpidsFrom\x12\x1b\n\
    \trtpids_to\x18\x03\x20\x03(\tR\x08rtpidsTo\"r\n\x19UpdateTransferRuleRe\
    quest\x12\x17\n\x07rule_id\x18\x01\x20\x01(\tR\x06ruleId\x12\x1f\n\x0brt\
    pids_from\x18\x02\x20\x03(\tR\nrtpidsFrom\x12\x1b\n\trtpids_to\x18\x03\
    \x20\x03(\tR\x08rtpidsTo\"\x8a\x01\n\x1aUpdateTransferRuleResponse\x12.\
    \n\x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclient.ResultR\x06result\
    \x12\x1f\n\x0brtpids_from\x18\x02\x20\x03(\tR\nrtpidsFrom\x12\x1b\n\trtp\
    ids_to\x18\x03\x20\x03(\tR\x08rtpidsTo\"4\n\x19DeleteTransferRuleRequest\
    \x12\x17\n\x07rule_id\x18\x01\x20\x01(\tR\x06ruleId\"L\n\x1aDeleteTransf\
    erRuleResponse\x12.\n\x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclient\
    .ResultR\x06result\"4\n\x13QuerySessionRequest\x12\x1d\n\nsession_id\x18\
    \x01\x20\x01(\tR\tsessionId\"\x82\x01\n\x14QuerySessionResponse\x12.\n\
    \x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclient.ResultR\x06result\
    \x12\x1b\n\tlocal_sdp\x18\x02\x20\x01(\tR\x08localSdp\x12\x1d\n\nremote_\
    sdp\x18\x03\x20\x01(\tR\tremoteSdp\"3\n\x18QueryTransferRuleRequest\x12\
    \x17\n\x07rule_id\x18\x01\x20\x01(\tR\x06ruleId\"\xd5\x01\n\x19QueryTran\
    sferRuleResponse\x12.\n\x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclie\
    nt.ResultR\x06result\x12&\n\x0fsession_id_from\x18\x02\x20\x01(\tR\rsess\
    ionIdFrom\x12\"\n\rsession_id_to\x18\x03\x20\x01(\tR\x0bsessionIdTo\x12\
    \x1f\n\x0brtpids_from\x18\x04\x20\x03(\tR\nrtpidsFrom\x12\x1b\n\trtpids_\
    to\x18\x05\x20\x03(\tR\x08rtpidsTo\">\n\x06Result\x12\x12\n\x04code\x18\
    \x01\x20\x01(\x05R\x04code\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\
    \x0bdescription\"\x1f\n\tMediaDesc\x12\x12\n\x04type\x18\x01\x20\x01(\tR\
    \x04type\"v\n\x0cTransferDesc\x12\x0e\n\x02IP\x18\x01\x20\x01(\tR\x02IP\
    \x12\x12\n\x04Port\x18\x02\x20\x01(\rR\x04Port\x12$\n\renablePortMux\x18\
    \x03\x20\x01(\x08R\renablePortMux\x12\x1c\n\tportMuxID\x18\x04\x20\x01(\
    \rR\tportMuxID\"Z\n\x11AddChannelRequest\x12\x12\n\x04type\x18\x01\x20\
    \x01(\tR\x04type\x12\x10\n\x03dir\x18\x02\x20\x01(\tR\x03dir\x12\x1f\n\
    \x0bendpoint_ID\x18\x03\x20\x01(\tR\nendpointID\"\xda\x01\n\x12AddChanne\
    lResponse\x12.\n\x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclient.Resu\
    ltR\x06result\x12\x14\n\x05rtpid\x18\x02\x20\x01(\tR\x05rtpid\x12-\n\x04\
    desc\x18\x03\x20\x01(\x0b2\x19.exchangeclient.MediaDescR\x04desc\x122\n\
    \x05local\x18\x04\x20\x01(\x0b2\x1c.exchangeclient.TransferDescR\x05loca\
    l\x12\x1b\n\tsrtp_desc\x18\x05\x20\x01(\tR\x08srtpDesc\"\x9e\x01\n\x19Up\
    dateMediaChannelRequest\x12\x14\n\x05rtpid\x18\x01\x20\x01(\tR\x05rtpid\
    \x12N\n\x14remote_transfer_desc\x18\x02\x20\x01(\x0b2\x1c.exchangeclient\
    .TransferDescR\x12remoteTransferDesc\x12\x1b\n\tsrtp_desc\x18\x03\x20\
    \x01(\tR\x08srtpDesc\"\xaf\x02\n\x1aUpdateMediaChannelResponse\x12.\n\
    \x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclient.ResultR\x06result\
    \x12\x14\n\x05rtpid\x18\x02\x20\x01(\tR\x05rtpid\x12-\n\x04desc\x18\x03\
    \x20\x01(\x0b2\x19.exchangeclient.MediaDescR\x04desc\x12L\n\x13local_tra\
    nsfer_desc\x18\x04\x20\x01(\x0b2\x1c.exchangeclient.TransferDescR\x11loc\
    alTransferDesc\x12N\n\x14remote_transfer_desc\x18\x05\x20\x01(\x0b2\x1c.\
    exchangeclient.TransferDescR\x12remoteTransferDesc\"H\n\x18DeleteMediaCh\
    annelRequst\x12\x14\n\x05rtpid\x18\x01\x20\x01(\tR\x05rtpid\x12\x16\n\
    \x06bForce\x18\x02\x20\x01(\x08R\x06bForce\"t\n\x1aDeleteMediaChannelRes\
    ponse\x12.\n\x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclient.ResultR\
    \x06result\x12\x12\n\x04srcs\x18\x02\x20\x03(\tR\x04srcs\x12\x12\n\x04ds\
    ts\x18\x03\x20\x03(\tR\x04dsts\"F\n\x0cTransferRule\x12\x12\n\x04from\
    \x18\x01\x20\x01(\tR\x04from\x12\x0e\n\x02to\x18\x02\x20\x01(\tR\x02to\
    \x12\x12\n\x04bAdd\x18\x03\x20\x01(\x08R\x04bAdd\"L\n\x16SetTransferRule\
    Request\x122\n\x05rules\x18\x01\x20\x03(\x0b2\x1c.exchangeclient.Transfe\
    rRuleR\x05rules\"\xfa\x01\n\x0bChannelInfo\x12-\n\x04desc\x18\x01\x20\
    \x01(\x0b2\x19.exchangeclient.MediaDescR\x04desc\x12L\n\x13local_transfe\
    r_desc\x18\x02\x20\x01(\x0b2\x1c.exchangeclient.TransferDescR\x11localTr\
    ansferDesc\x12N\n\x14remote_transfer_desc\x18\x03\x20\x01(\x0b2\x1c.exch\
    angeclient.TransferDescR\x12remoteTransferDesc\x12\x1e\n\nbConnected\x18\
    \x04\x20\x01(\x08R\nbConnected\"+\n\x13QueryChannelRequest\x12\x14\n\x05\
    rtpid\x18\x01\x20\x01(\tR\x05rtpid\"y\n\x14QueryChannelResponse\x12.\n\
    \x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclient.ResultR\x06result\
    \x121\n\x05infos\x18\x02\x20\x03(\x0b2\x1b.exchangeclient.ChannelInfoR\
    \x05infos\"1\n\x19QuerySrcByConsumerRequest\x12\x14\n\x05rtpid\x18\x01\
    \x20\x01(\tR\x05rtpid\"b\n\x1aQuerySrcByConsumerResponse\x12.\n\x06resul\
    t\x18\x01\x20\x01(\x0b2\x16.exchangeclient.ResultR\x06result\x12\x14\n\
    \x05rtpid\x18\x02\x20\x01(\tR\x05rtpid\"2\n\x1aQueryConsumersBySrcReques\
    t\x12\x14\n\x05rtpid\x18\x01\x20\x01(\tR\x05rtpid\"e\n\x1bQueryConsumers\
    BySrcResponse\x12.\n\x06result\x18\x01\x20\x01(\x0b2\x16.exchangeclient.\
    ResultR\x06result\x12\x16\n\x06rtpids\x18\x02\x20\x03(\tR\x06rtpids\"2\n\
    \x0cTransferPair\x12\x12\n\x04from\x18\x01\x20\x01(\tR\x04from\x12\x0e\n\
    \x02to\x18\x02\x20\x01(\tR\x02to\"\x1a\n\x18QueryAllRelationsRequest\"\
    \x87\x01\n\x19QueryAllRelationsResponse\x12.\n\x06result\x18\x01\x20\x01\
    (\x0b2\x16.exchangeclient.ResultR\x06result\x12:\n\trelations\x18\x02\
    \x20\x03(\x0b2\x1c.exchangeclient.TransferPairR\trelations*C\n\nEMediaTy\
    pe\x12\x13\n\x0fMEDIA_TYPE_NONE\x10\0\x12\t\n\x05AUDIO\x10\x01\x12\t\n\
    \x05VIDEO\x10\x02\x12\n\n\x06AVBOTH\x10\x03*H\n\x0fEMediaDirection\x12\
    \x0b\n\x07DIRNONE\x10\0\x12\x0c\n\x08SENDONLY\x10\x01\x12\x0c\n\x08RECVO\
    NLY\x10\x02\x12\x0c\n\x08SENDRECV\x10\x032\x86\r\n\x14MediaExchangeServi\
    ce\x12Z\n\x0fAddMediaSession\x12!.exchangeclient.AddSessionRequest\x1a\"\
    .exchangeclient.AddSessionResponse\"\0\x12c\n\x12UpdateMediaSession\x12$\
    .exchangeclient.UpdateSessionRequest\x1a%.exchangeclient.UpdateSessionRe\
    sponse\"\0\x12c\n\x12DeleteMediaSession\x12$.exchangeclient.DeleteSessio\
    nRequest\x1a%.exchangeclient.DeleteSessionResponse\"\0\x12d\n\x0fAddTran\
    sferRule\x12&.exchangeclient.AddTransferRuleRequest\x1a'.exchangeclient.\
    AddTransferRuleResponse\"\0\x12m\n\x12UpdateTransferRule\x12).exchangecl\
    ient.UpdateTransferRuleRequest\x1a*.exchangeclient.UpdateTransferRuleRes\
    ponse\"\0\x12m\n\x12DeleteTransferRule\x12).exchangeclient.DeleteTransfe\
    rRuleRequest\x1a*.exchangeclient.DeleteTransferRuleResponse\"\0\x12`\n\
    \x11QueryMediaSession\x12#.exchangeclient.QuerySessionRequest\x1a$.excha\
    ngeclient.QuerySessionResponse\"\0\x12j\n\x11QueryTransferRule\x12(.exch\
    angeclient.QueryTransferRuleRequest\x1a).exchangeclient.QueryTransferRul\
    eResponse\"\0\x12Z\n\x0fAddMediaChannel\x12!.exchangeclient.AddChannelRe\
    quest\x1a\".exchangeclient.AddChannelResponse\"\0\x12m\n\x12UpdateMediaC\
    hannel\x12).exchangeclient.UpdateMediaChannelRequest\x1a*.exchangeclient\
    .UpdateMediaChannelResponse\"\0\x12l\n\x12DeleteMediaChannel\x12(.exchan\
    geclient.DeleteMediaChannelRequst\x1a*.exchangeclient.DeleteMediaChannel\
    Response\"\0\x12S\n\x0fSetTransferRule\x12&.exchangeclient.SetTransferRu\
    leRequest\x1a\x16.exchangeclient.Result\"\0\x12[\n\x0cQueryChannel\x12#.\
    exchangeclient.QueryChannelRequest\x1a$.exchangeclient.QueryChannelRespo\
    nse\"\0\x12m\n\x12QuerySrcByConsumer\x12).exchangeclient.QuerySrcByConsu\
    merRequest\x1a*.exchangeclient.QuerySrcByConsumerResponse\"\0\x12p\n\x13\
    QueryConsumersBySrc\x12*.exchangeclient.QueryConsumersBySrcRequest\x1a+.\
    exchangeclient.QueryConsumersBySrcResponse\"\0\x12j\n\x11QueryAllRelatio\
    ns\x12(.exchangeclient.QueryAllRelationsRequest\x1a).exchangeclient.Quer\
    yAllRelationsResponse\"\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
